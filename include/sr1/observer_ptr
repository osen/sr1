#ifndef STD_SR1_OBSERVERPTR
#define STD_SR1_OBSERVERPTR

#include "shared_ptr"
#include "weak_ptr"

#include <memory>

namespace std
{

namespace sr1
{

template <typename T>
struct _enable_observer;

template <typename T>
struct observer_ptr
{
  /*********************************************************
   * Default Constructor
   *********************************************************/
  observer_ptr() { }

  /*********************************************************
   * Copy Constructor
   *********************************************************/
  observer_ptr(const observer_ptr& t)
  {
    operator=(t);
  }

  /*********************************************************
   * Template Copy Constructor
   *********************************************************/
  template <typename R>
  observer_ptr(const observer_ptr<R>& r)
  {
    operator=(r);
  }

  /*********************************************************
   * Raw Pointer Constructor
   *********************************************************/
  template <typename R>
  observer_ptr(R* r)
  {
    operator=(r);
  }

  /*********************************************************
   * Unique Pointer Constructor
   *********************************************************/
  template <typename R>
  observer_ptr(const std::unique_ptr<R>& r)
  {
    operator=(r);
  }

  /*********************************************************
   * Shared Pointer Constructor
   *********************************************************/
  template <typename R>
  observer_ptr(const shared_ptr<R>& r)
  {
    operator=(r);
  }

  /*********************************************************
   * Weak Pointer Constructor
   *********************************************************/
  template <typename R>
  observer_ptr(const weak_ptr<R>& r)
  {
    operator=(r);
  }

  /*********************************************************
   * =
   *
   * Allows for a copy assignment.
   *********************************************************/
  observer_ptr& operator=(const observer_ptr<T>& t)
  {
    reset(t);

    return *this;
  }

  /*********************************************************
   * =
   *
   * Allows for a copy assignment of template type.
   *********************************************************/
  template <typename R>
  observer_ptr& operator=(const observer_ptr<R>& r)
  {
    reset(r);

    return *this;
  }

  /*********************************************************
   * =
   *
   * Allows for assignment of a raw pointer.
   *********************************************************/
  template <typename R>
  observer_ptr& operator=(R* r)
  {
    reset(r);

    return *this;
  }

  /*********************************************************
   * =
   *
   * Allows for assignment of a unique_ptr.
   *********************************************************/
  template <typename R>
  observer_ptr& operator=(const std::unique_ptr<R>& r)
  {
    reset(r);

    return *this;
  }

  /*********************************************************
   * =
   *
   * Allows for assignment of a shared_ptr.
   *********************************************************/
  template <typename R>
  observer_ptr& operator=(const shared_ptr<R>& r)
  {
    reset(r);

    return *this;
  }

  /*********************************************************
   * =
   *
   * Allows for assignment of a weak_ptr.
   *********************************************************/
  template <typename R>
  observer_ptr& operator=(const weak_ptr<R>& r)
  {
    reset(r);

    return *this;
  }

  /*********************************************************
   * *
   *
   * Allows for dereference [*var].
   *********************************************************/
  T& operator*() const
  {
    return *ptr.lock();
  }

  /*********************************************************
   * ->
   *
   * Allows for dereference [var->]. Use shared_ptr_lock_ptr
   * instead to ensure that correct locking occurs
   * throughout usage of the data. Preventing erroneous
   * deletion whilst the data is in use. The Drilldown
   * mechanism should ensure it correctly behaves like a raw
   * pointer.
   *********************************************************/
  shared_ptr_lock_ptr<T> operator->() const
  {
    //return shared_ptr_lock_ptr<T>(ptr.lock().ref);
    return shared_ptr_lock_ptr<T>(ptr.ref);
  }

  //shared_ptr<T> operator->() const
  //{
  //  return ptr.lock();
  //}

  /*********************************************************
   * ->
   *
   * Allows for dereference [var->]. This is disabled
   * because it simply returns a raw pointer. It does not
   * do the lifetime locking allowing for dangling "this".
   *********************************************************/
  //T* operator->() const
  //{
  //  return get();
  //}

  template <typename R>
  void reset(const std::unique_ptr<R>& r)
  {
    reset(r.get());
  }

  template <typename R>
  void reset(const weak_ptr<R>& r)
  {
    reset(r.lock());
  }

  template <typename R>
  void reset(const shared_ptr<R>& r)
  {
    reset(r.get());
  }

  template <typename R>
  void reset(const observer_ptr<R>& r)
  {
    reset(r.get());
  }

  template <typename R>
  void reset(R* r)
  {
    ptr = static_pointer_cast<R>(r->self);
  }

  void reset()
  {
    ptr.reset();
  }

  /*********************************************************
   * bool
   *
   * Allows for initialized check [if(var)].
   *********************************************************/
  operator bool() const
  {
    return !operator!();
  }

  /*********************************************************
   * !
   *
   * Allows for not initialized check [if(!var)].
   *********************************************************/
  bool operator!() const
  {
    return get() == NULL;
  }

  /*********************************************************
   * ==
   *
   * Allows for equality check [if(varA == varB)].
   *********************************************************/
  bool operator==(const observer_ptr& other) const
  {
    return !operator!=(other);
  }

  /*********************************************************
   * ==
   *
   * Allows for inequality check [if(varA != varB)].
   *********************************************************/
  bool operator!=(const observer_ptr& other) const
  {
    return get() != other.get();
  }

private:
  template <typename R>
  friend struct observer_ptr;

  weak_ptr<T> ptr;

  /*********************************************************
   * get
   *
   * Provides a way to recover the pointer.
   *********************************************************/
  T* get() const
  {
    return ptr.lock().get();
  }

};

template <typename T>
struct _enable_observer
{
  _enable_observer()
  {
    self.reset(this, dummy);
  }

private:
  template <typename R>
  friend struct observer_ptr;

  static void dummy(_enable_observer* ptr) { }

  shared_ptr<_enable_observer> self;

};

using enable_observer = _enable_observer<int>;

}

}

#endif

