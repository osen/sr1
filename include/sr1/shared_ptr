#ifndef STD_SR1_SHAREDPTR
#define STD_SR1_SHAREDPTR

#include "zero_initialized"

#include <iostream>

#include <cstddef>

namespace std
{

namespace sr1
{

#ifdef STD_SR1_DEBUG

struct shared_ptr_refcount
{
  shared_ptr_refcount() : ptr(NULL), deleter(NULL) { }

  zero_initialized<size_t> count;
  void *ptr;
  void (*deleter)(void *);
};

template <typename T>
void shared_ptr_deleter(void *ptr)
{
  T *t = (T *)ptr;

  delete t;
}

template <typename T>
class shared_ptr;

template <typename T>
class shared_ptr_lock
{
public:
  shared_ptr_lock(shared_ptr<T>* owner) : owner(owner)
  {
    // TODO: Initializer list parameter with same name as argument
    // All compilers support this? C++98
    this->owner = owner;
    owner->locks++;
  }

  shared_ptr_lock(const shared_ptr_lock<T>& other) : owner(NULL)
  {
    *this = other;
  }

  virtual ~shared_ptr_lock()
  {
    owner->locks--;
  }

protected:
  shared_ptr<T>* owner;

private:
  shared_ptr_lock& operator=(const shared_ptr_lock& other)
  {
    if(owner)
    {
      owner->locks--;
    }

    owner = other.owner;
    owner->locks++;

    return *this;
  }

};

template <typename T>
class shared_ptr_lock_ptr : public shared_ptr_lock<T>
{
public:
  shared_ptr_lock_ptr(shared_ptr<T> *owner) : shared_ptr_lock<T>(owner) { }

  operator T*()
  {
    return this->owner->get();
  }

  T& operator*()
  {
    return *this->owner->get();
  }

  T* operator->()
  {
    return this->owner->get();
  }
};

template <typename T>
class shared_ptr_lock_ref : public shared_ptr_lock<T>
{
public:
  shared_ptr_lock_ref(shared_ptr<T> *owner) : shared_ptr_lock<T>(owner) { }

  operator T&()
  {
    return *this->owner->get();
  }
};

template <typename T>
class shared_ptr
{
  friend class shared_ptr_lock_ptr<T>;
  friend class shared_ptr_lock_ref<T>;

public:
  shared_ptr() : ref(NULL), locks(0) { }

  shared_ptr& operator=(const shared_ptr& other)
  {
    aquire(other.ref);

    return *this;
  }

  shared_ptr(const shared_ptr& copy) : ref(NULL), locks(0)
  {
    *this = copy;
  }

  template <typename U>
  shared_ptr& operator=(const shared_ptr<U>& other)
  {
    T *t = static_cast<U*>(NULL);
    aquire(other.ref);

    return *this;
  }

  template <typename U>
  shared_ptr(const shared_ptr<U>& copy) : ref(NULL), locks(0)
  {
    *this = copy;
  }

  ~shared_ptr()
  {
    reset();
  }

  shared_ptr_lock_ptr<T> operator->()
  {
    return shared_ptr_lock_ptr<T>(this);
  }

  shared_ptr_lock_ref<T> operator*()
  {
    return shared_ptr_lock_ref<T>(this);
  }

private:
  T *get()
  {
    T *t = NULL;

    if(ref)
    {
      t = (T *)ref->ptr;
    }

    return t;
  }

  void reset()
  {
    if(!ref)
    {
      return;
    }

    if(locks)
    {
      std::cerr << "Attempt to release locked reference" << std::endl;
      abort();
    }

    ref->count--;

    if(ref->count < 1)
    {
      ref->deleter(ref->ptr);
      delete ref;
    }

    ref = NULL;
  }

// TODO: Allow the following to be private
public:
  shared_ptr_refcount *ref;
  size_t locks;

  void aquire(shared_ptr_refcount *ref)
  {
    if(ref == this->ref)
    {
      return;
    }

    reset();

    if(!ref)
    {
      return;
    }

    this->ref = ref;
    ref->count++;
  }

};

template <typename T>
shared_ptr<T> make_shared()
{
  shared_ptr<T> rtn;

  shared_ptr_refcount *ref = new shared_ptr_refcount();
  ref->ptr = new T();
  ref->deleter = shared_ptr_deleter<T>;
  rtn.aquire(ref);

  return rtn;
}

#else

using std::shared_ptr;
using std::make_shared;

#endif

}

}

#endif
