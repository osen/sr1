#ifndef STD_SR1_MEMORY
#define STD_SR1_MEMORY

#include "zero_initialized"

#include <memory>
#include <iostream>

namespace std
{

namespace sr1
{

#ifdef STD_SR1_DEBUG

template <typename T>
class shared_ptr
{
public: // TODO: make_shared friend function / class
  std::shared_ptr<T> data;
  zero_initialized<size_t> refs;

  void check_valid()
  {
    if(refs != 0)
    {
      std::cerr << "Attempting to delete active memory" << std::endl;
      abort();
    }
  }

public:
  shared_ptr() { }

  ~shared_ptr()
  {
    check_valid();
  }

  shared_ptr(const shared_ptr& other)
  {
    *this = other;
  }

  shared_ptr& operator=(const shared_ptr& other)
  {
    check_valid();
    data = other.data;

    return *this;
  }

  void reset()
  {
    check_valid();
    data.reset();
  }

  class shared_ptr_lock
  {
  protected:
    zero_initialized<shared_ptr*> owner;

  public:
    shared_ptr_lock(shared_ptr* owner)
    {
      this->owner = owner;
      owner->refs++;
    }

    shared_ptr_lock(const shared_ptr_lock& other)
    {
      *this = other;
    }

    shared_ptr_lock& operator=(const shared_ptr_lock& other)
    {
      if(owner)
      {
        owner->refs--;
      }

      owner = other.owner;
      owner->refs++;

      return *this;
    }

    virtual ~shared_ptr_lock()
    {
      owner->refs--;
    }
  };

  class shared_ptr_lock_ptr : public shared_ptr_lock
  {
  public:
    shared_ptr_lock_ptr(shared_ptr* owner) : shared_ptr_lock(owner) { }

    operator T*()
    {
      return this->owner->data.get();
    }

    T& operator*()
    {
      return *this->owner->data;
    }

    T* operator->()
    {
      return this->owner->data.get();
    }
  };

  class shared_ptr_lock_ref : public shared_ptr_lock
  {
  public:
    shared_ptr_lock_ref(shared_ptr* owner) : shared_ptr_lock(owner) { }

    operator T&()
    {
      return *this->owner->data;
    }
  };

  shared_ptr_lock_ptr operator->()
  {
    return shared_ptr_lock_ptr(this);
  }

  shared_ptr_lock_ptr get()
  {
    return shared_ptr_lock_ptr(this);
  }

  shared_ptr_lock_ref operator*()
  {
    return shared_ptr_lock_ref(this);
  }
};

template <typename T>
shared_ptr<T> make_shared()
{
  shared_ptr<T> rtn;
  rtn.data = std::make_shared<T>();
  return rtn;
}

template <typename T, typename A>
shared_ptr<T> make_shared(A& a)
{
  shared_ptr<T> rtn;
  rtn.data = std::make_shared<T>(a);
  return rtn;
}

#else

using std::shared_ptr;
using std::make_shared;

#endif

}

}

#endif

